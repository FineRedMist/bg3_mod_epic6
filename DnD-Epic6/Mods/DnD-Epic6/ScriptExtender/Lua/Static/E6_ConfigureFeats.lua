--[[
    This file will go through the currently loaded mods and determine which of the spells that correspond
    to feats need to be connected. The spells have already been generated by FeatExtractor, a tool that 
    canvasses the content in the game and various mods to extract the list of feats, ability, skills, spells,
    etc, to determine what can be wired for granting.

    Essentially, feat extractor will automatically generate the various Shout spells for each feat, and the 
    corresponding feat to grant based on it. The feats will be pregenerated as well to grant the passives, spells, abilities, or skills. 

    Determine the mod loading order:
        Then in order, maintain a table mapping 
            feat -> Spec: feat information
                -> Desc: feat description (for showing in the UI spell description)
            ability pool id -> abilities
            ability -> description (for showing in the UI spell description)
            skill pool id => skills
            skill -> description (for showing in the spell description)
            spell pool id -> spells
            spell -> description (for spell description granting the spell, note, I may not have all of these spells available, so I can only do the ones that work)
        
    Since the "spell" granting a feat with spells will have to have tiers of selection, I'll have to populate that list at runtime for the spells that are selectable.

    Note the number of feats and spells will be combinatorially large because of this. Ideally we could hook into the UI itself for level up, but that is apparently well outside what is achievable.
]]

local function E6_NormalizeModName(modName)
   return string.gsub(modName, "[^a-zA-Z0-9]", "_")
end

local function E6_AddSpellToContainerSpell(spellContainer, spellName)
    if spellContainer.ContainerSpells == nil or string.len(spellContainer.ContainerSpells) == 0 then
        spellContainer.ContainerSpells = spellName
    else
        spellContainer.ContainerSpells = spellContainer.ContainerSpells .. ";" .. spellName
    end
    return true
end


local function E6_WireFeats(spellWiring, updatedSpells, modOrder)
    for spellContainerName, tiers in pairs(spellWiring) do
        local spellContainer = Ext.Stats.Get(spellContainerName)
        for _, tier in ipairs(tiers) do
            for _, modName in ipairs(modOrder) do
                if tier[modName] ~= nil then
                    for _, spellName in ipairs(tier[modName]) do
                        E6_AddSpellToContainerSpell(spellContainer, spellName)
                        updatedSpells[spellContainerName] = true
                    end
                    break
                end
            end
        end
    end
end

local function E6_OnStatsLoaded()
    -- Get the spell wiring file and load it.
    local spellWiring = Ext.IO.LoadFile("Public/DnD-Epic6/Stats/Generated/Data/E6_Gen_Wiring.json", "data")
    if spellWiring == nil then
        Ext.Utils.PrintError("DnD-Epic6: Failed to load spell wiring file.")
        return
    end
    local spellWiring = Ext.Json.Parse(spellWiring)
    if spellWiring == nil then
        Ext.Utils.PrintError("DnD-Epic6: Failed to parse spell wiring file.")
        return
    end

    local updatedSpells = {}
    
    -- Go in reverse order through the mod load order to identify the active version of the feat.
    local modOrder = Ext.Mod.GetLoadOrder()
    local modNameOrder = {}

    for i = #modOrder, 1, -1 do
        local uuid = modOrder[i]
        local v = Ext.Mod.GetMod(uuid)
        modNameOrder[#modNameOrder+1] = E6_NormalizeModName(v.Info.Name)
    end

    E6_WireFeats(spellWiring, updatedSpells, modNameOrder)

    for spellName, _ in pairs(updatedSpells) do
        local spell = Ext.Stats.Get(spellName)
        spell:Sync()
    end
end

function E6_ConfigureFeats()
    Ext.Events.StatsLoaded:Subscribe(E6_OnStatsLoaded)
end
